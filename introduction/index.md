> [home](../)

![banner](/wfs/photos/banner.png)

## Introduction

> Data dominates.
> If you've chosen the right data structures and organized things well,
> the algorithms will almost always be self-evident.
> Data structures, not algorithms, are central to programming.  
> **Rob Pike**

Here we take the perspective that any given system system is
a cluster of intelligence that can be meaningfully sliced into
smaller clusters of intelligence (**IC**s &#x1F609;).
It helps if you have already had a look at [cdi&trade;](/cdi).

We also take the perspective that both data and algorithms are
pieces of intelligence that can be captured inside a computational system as knowledge.
Thus an integer is a piece of knowledge.
The algorithm to add two integers together is also a piece of knowledge.
Thus a class _number_ that contains an integer and the manipulations thereof
is a cluster of knowledge.

We can now see clearly that both data and algorithms are ultimately knowledge and
are readily represented as data.
A _processor_ is the only thing that distinguishes between _data_ and _algotrithms_
and brings _action_ to _life_ inside a computer.
For humans, everything is just knowledge — to be sure, just data.

The most fundamental and universal data structure is a tree.
Any arbitrary cluster of knowledge can be captured into
a tree of smaller clusters of knowledge.

> Designing a system thus becomes the discipline of
> organizing clusters of knowledge — an exercise in knowledge management
> using microservices.

A cluster of knowledge has a _root_ or a _handle_.
Any arbitrary graph of knowledge can be considered a cluster when you give
the cluster a _name_ — an _access point_ — which becomes its _root_.
Any given system can thus be defined in terms of:

* Clusters of Knowledge (**KC**s)
* Access Points (**AP**s)

> The astute observer may have realized that we are simply speaking of _RAM_
> and _pointers_.
> Metaphorically, this is just a folder structure and pathnames.
> Now, imagine a _golang_ source tree.

A well-factored system is an organized breakdown of a resilient factoring of
system functionality driven by two principles:

* Single Responsibility Principle (**SRP**)
* Don't Repeat Yourself (**DRY**)

Inside this _KC_ called [wfs&trade;](/wfs), we explore the ramifications of
this perspective.
